from ..test import ExperimentTest, Results
import os

class HasCorrectItems(ExperimentTest):
    '''Passes if an ANTS resource is found and such resource has the main
    expected items.'''

    passing = 'BBRCDEV_E01613',
    failing = 'BBRCDEV_E00272',

    def run(self, experiment_id):
        from fnmatch import fnmatch

        expected_items = ['*T1space_affine.txt',
                          '*T1space.nii.gz'
                          ]

        res = self.xnat_instance.select.experiment(experiment_id)\
            .resource('ANTS')

        file_list = set([e.attributes()['Name'] for e in res.files()])

        for e in expected_items:
            if not [f for f in file_list if fnmatch(f, e)] :
                return Results(False, data=['ANTS %s matching item not found.'%e])

        return Results(True, data=[])


class HasCorrectANTsVersion(ExperimentTest):
    '''This test checks the ANTs version used for processing the images. Passes
    if ANTS outputs were created using the expected (`2.3.1.0`) version.'''

    passing = 'BBRCDEV_E01613',
    failing = 'BBRCDEV_E00272',

    def run(self, experiment_id):

        expected_ants_version = 'ANTs Version: 2.3.1.0.post149-gd15f7'

        data = self.xnat_instance.array.mrsessions(experiment_id=experiment_id,
                                                   columns=['label']
                                                   ).data
        exp_label, project, subject_id = [data[0][e] for e in \
            ['label', 'project', 'xnat:mrsessiondata/subject_id']]

        res = self.xnat_instance.select.project(project).subject(subject_id)\
            .experiment(experiment_id).resource('ANTS')

        if res.file('LOGS/%s.log' % exp_label).exists():
            log = res.file('LOGS/%s.log' % exp_label)
        else:
            return Results(False, data=['ANTS log file not found.'])

        log_data = self.xnat_instance.get(log.attributes()['URI']).text
        ants_version = [line for line in log_data.splitlines() if line.startswith('ANTs Version')]

        if not ants_version or not ants_version[0].startswith(expected_ants_version) :
            return Results(False, data=['%s' % ants_version[0]])

        return Results(True, data=[])

class ANTSSnapshot(ExperimentTest):
    '''This generates a snapshot of the results generated by ANTS.
    Passes if the snapshot is created successfully. Fails otherwise. Does not
    tell anything on the segmentation quality. '''

    passing = 'BBRCDEV_E01613',
    failing = 'BBRCDEV_E00754', # has no ANTS resource

    def run(self, experiment_id):
        import tempfile, os
        import logging as log

        if os.environ.get('SKIP_SNAPSHOTS_TESTS'):
            return Results(experiment_id == self.passing[0],
                data=['Skipping it. (SKIP_SNAPSHOTS_TESTS)'])

        r = self.xnat_instance.select.experiment(experiment_id).resource('ANTS')
        if not r.exists():
            log.error('ANTS resource not found for %s'%experiment_id)
            return Results(False, data=['ANTS resource not found'])

        f = [e for e in list(r.files()) \
            if 'T1space' in e.label() and e.label().endswith('.nii.gz')][0]

        fd1, t2_mri_path = tempfile.mkstemp(suffix='.nii.gz')
        f.get(t2_mri_path)

        from ..sanity import data
        p = data.HasPreferredT1(self.lut, self.xnat_instance)
        e = p.preferred_T1(experiment_id)

        resources_files = list(self.xnat_instance.select.experiment(experiment_id)\
                .scan(e).resource('NIFTI').files())

        if len(resources_files) == 0:
            return Results(False, data=['T1 not found.'])

        for f in resources_files:
            if f.label().endswith('.nii.gz'):
                break
        fd2, t1_mri_path = tempfile.mkstemp(suffix='.nii.gz')
        f.get(t1_mri_path)

        from . import snapshot
        res = snapshot(t1_mri_path, t2_mri_path, 'ANTS')

        return res

    def report(self):
        report = []
        path = self.results.data[0]
        report.append('![snapshot](%s)'%path)
        return report
