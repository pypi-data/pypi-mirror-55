"""SConsider.site_tools.generateScript.

SConsider-specific stand alone script to execute programs

"""
# vim: set et ai ts=4 sw=4:
# -------------------------------------------------------------------------
# Copyright (c) 2009, Peter Sommerlad and IFS Institute for Software
# at HSR Rapperswil, Switzerland
# All rights reserved.
#
# This library/application is free software; you can redistribute and/or
# modify it under the terms of the license that is included with this
# library/application in the file license.txt.
# -------------------------------------------------------------------------

import os
import datetime
import tempfile
import SCons.Action
import SCons.Builder
import SomeUtils


def generateShellScript(scriptFile, env, binpath):
    pwdCommand = 'pwd -P'
    defaultExpansions = [
        ('LIBDIR', lambda env: env['LIBDIR']),
        ('BINDIR', lambda env: env['BINDIR']),
        ('CONFIGDIR', lambda env: env['CONFIGDIR']),
        ('SCRIPTDIR', lambda env: env['SCRIPTDIR']),
        ('VARIANTDIR', lambda env: env.getRelativeVariantDirectory()),
        ('BINARYNAME', os.path.basename(binpath)),
        ('BASEDIR',
         '`searchBaseDirUp \\"${SCRIPTPATH}\\" \\"${SCRIPTDIR}\\"`'),
    ]

    specificExtensions = []
    if env['PLATFORM'] == 'darwin':
        libpathvariable = 'DYLD_LIBRARY_PATH'
    else:
        libpathvariable = 'LD_LIBRARY_PATH'
    if 'mingw' in env['TOOLS']:
        pwdCommand = 'pwd'
        libpathvariable = 'PATH'
    if 'GENERATESCRIPTVARS' in env:
        specificExtensions += env['GENERATESCRIPTVARS']

    def expandvars(env, expansions=[]):
        stringToReturn = ''
        exportvars = 'export'
        for k, v in expansions:
            try:
                stringToReturn += k + '="' + (v(env)
                                              if callable(v) else str(v)) + '"\n'
                exportvars += ' ' + k
            except:
                pass
        if stringToReturn:
            stringToReturn += exportvars + '\n'
        return stringToReturn

    scriptText = """#!/bin/bash
# -------------------------------------------------------------------------
# Copyright (c) """ + datetime.date.today().strftime('%Y') + """, Peter Sommerlad and IFS Institute for Software
# at HSR Rapperswil, Switzerland
# All rights reserved.
#
# This library/application is free software; you can redistribute and/or
# modify it under the terms of the license that is included with this
# library/application in the file license.txt.
# -------------------------------------------------------------------------
# Autogenerated by SConsider; do not edit!

GDBSERVERPORT=2345

MYNAME="`basename \\"$0\\"`"
SCRIPTPATH="`dirname \\"$0\\"`"
SCRIPTPATH="`cd \\"$SCRIPTPATH\\" 2>/dev/null && """ + pwdCommand + """`"
STARTPATH="`""" + pwdCommand + """`"

doChangeDir=1
doDebug=0
doDebugServer=0
doTrace=0
declare -a cmdArr
doCommandWithArgs=0

showhelp()
{
    echo ''
    echo 'usage: '$MYNAME' [options]'
    echo 'where options are:'
    echo ' -d             : run under debugger control (gdb)'
    echo ' -e             : run under debugger control in your IDE (gdbserver)'
    echo ' -S             : do not change directory before executing target'
    echo '                  eg. stay in current directory for executino'
    echo ' -x <tool|opts> : run <tool tool-opts server-command server-options>'
    echo '                  to specify tool options, use multiple -x <opts> options'
    echo ' -v             : verbose mode'
    echo .
    exit 3;
}

OPTIND=1
while getopts ":deSvx:-" opt
do
    case $opt in
        :)
            echo "ERROR: -$OPTARG parameter missing, exiting!";
            showhelp;
        ;;
        d)
            doDebug=1;
        ;;
        e)
            doDebugServer=1;
        ;;
        S)
            doChangeDir=0;
        ;;
        v)
            doTrace=1;
        ;;
        x)
            cmdArr=(${cmdArr[@]} $OPTARG);
        ;;
        -)
            break;
        ;;
        \?)
            showhelp;
        ;;
    esac
done

shift `expr $OPTIND - 1`

# find base directory for a given path
# param 1: path to start from
# param 2: is the path segment to search for
# param 3: value to return if search failed, default ""
searchBaseDirUp()
{
    start_dir="${1}";
    searchSegment="${2}";
    dirDefault="${3}";
    basePath="`cd \\"$start_dir\\" &&
        while [ ! -d \\"${searchSegment}\\" ] && [ \\"\`pwd\`\\" != / ]; do
            cd .. 2>/dev/null;
        done;
        """ + pwdCommand + """
    `";
    test -d "${basePath}/${searchSegment}" || basePath="${dirDefault}";
    echo "$basePath";
}

die() {
    printf "%s\n" "$@";
    exit 1;
}

""" + expandvars(env, defaultExpansions) + """
# find the base directory
LIBDIR_BASE="`searchBaseDirUp \\"${SCRIPTPATH}\\" \\"${LIBDIR}\\"`"

test -n "${LIBDIR_BASE}" || die "No base directory found containing library directory [$LIBDIR], exiting."

ABS_LIBDIR="${LIBDIR_BASE}/${LIBDIR}"
test -d "${ABS_LIBDIR}/${VARIANTDIR}" && ABS_LIBDIR="${ABS_LIBDIR}/$VARIANTDIR"

""" + libpathvariable + """="${ABS_LIBDIR}":$""" + libpathvariable + """
export """ + libpathvariable + """

BINDIR_BASE="`searchBaseDirUp \\"${SCRIPTPATH}\\" \\"${BINDIR}\\"`"

test -n "${BINDIR_BASE}" || die "No base directory found containing binary directory [$BINDIR], exiting."

ABS_BINDIR="${BINDIR_BASE}/${BINDIR}"
test -d "${ABS_BINDIR}/${VARIANTDIR}" && ABS_BINDIR="${ABS_BINDIR}/$VARIANTDIR"

""" + expandvars(env, specificExtensions) + """
# generate gnu debugger command file which may be used for batch
# invocations of the debugger.
#
# param 1: is the name of the generated batch file
# param 2: binary to execute
# param 3: run executable in background, default 1, set to 0 to run gdb in foreground
# param 4.. arguments passed to the debugged program
#
generateGdbCommandFile()
{
    ggcfBatchFile="${1}";
    ggcfBinaryToExecute="${2}";
    ggcfRunInBackground=${3};
    test $# -ge 3 || return 1;
    shift 3
    ggcfServerOptions="$@";
    # <<-EOF ignore tabs, nice for formatting heredocs
cat > ${ggcfBatchFile} <<-EOF
	handle SIGSTOP nostop nopass
	handle SIGLWP  nostop pass
	handle SIGTERM nostop pass
	handle SIGINT  nostop pass
	set environment PATH=${PATH}
	set environment COAST_ROOT=${COAST_ROOT}
	set environment COAST_PATH=${COAST_PATH}
	set environment """ + libpathvariable + """=${""" + libpathvariable + """}
	set auto-solib-add 1
	# convert to Windows path on mingw (msys supplies it automatically to non-msys tools)
	file \"""" + ("`cmd //c echo ${ggcfBinaryToExecute}`" if "mingw" in env["TOOLS"] else "${ggcfBinaryToExecute}") + """\"
	set args ${ggcfServerOptions}
EOF
    if [ $ggcfRunInBackground -eq 1 ]; then
cat >> ${ggcfBatchFile} <<-EOF
	set pagination 0
	run
	! echo "\`date +'%Y%m%d%H%M%S'\`: ========== GDB backtrace =========="
	backtrace full
	info registers
	x/16i \$pc
	thread apply all backtrace
	continue
	shell rm ${ggcfBatchFile}
	quit
EOF
    fi;
}

CMD="${ABS_BINDIR}/${BINARYNAME}"
test -x "${CMD}" || die "binary [${CMD}] is not executable, aborting!"

test ${doChangeDir} -eq 1 -a -d "${BINDIR_BASE}" && cd "${BINDIR_BASE}"

test ${doTrace} -eq 1 && ( cat <<EOF
Executing command [${CMD}]
 with arguments   [$@]
 in directory     [`pwd`]
EOF
)

toolPath=$(which ${cmdArr[0]} 2>/dev/null)
if [ -n "$toolPath" ]; then
    doCommandWithArgs=1
fi
if [ ${doDebug:-0} -eq 1 ]; then
    cfg_gdbcommands=\"""" + (tempfile.gettempdir() + os.sep).replace('\\', '/') + """`basename \\"$0\\"`_$$";
    generateGdbCommandFile "${cfg_gdbcommands}" "$CMD" 0 "$@"
    test ${doTrace} -eq 1 && echo "Generated gdb command file:"
    test ${doTrace} -eq 1 && cat ${cfg_gdbcommands}
    gdb --command ${cfg_gdbcommands}
elif [ ${doDebugServer:-0} -eq 1 -a -x "$(which gdbserver)" ]; then
    gdbserver :${GDBSERVERPORT} "${CMD}" "$@"
elif [ ${doCommandWithArgs:-0} -eq 1 ]; then
    test ${doTrace} -eq 1 && echo "executing command [${cmdArr[*]} ${CMD} $@]"
    eval "${cmdArr[*]} ${CMD} $@"
else
    "$CMD" "$@"
fi

exit $?
"""
    scriptFile.write(scriptText)


def generatePosixScript(target, source, env):
    for t, s in zip(target, source):
        scriptFile = open(str(t), 'w')
        generateShellScript(scriptFile, env, s.get_path())
        scriptFile.close()
    return 0


def generateScriptEmitter(target, source, env):
    target = []
    for src in source:
        script_name = os.path.basename(src.get_abspath()) + '.sh'
        if script_name.startswith('bin_'):
            script_name = script_name.partition('_')[2]
        target.append(env.getScriptInstallDir().File(script_name))
    return (target, source)


def generateWrapperScript(env, target):
    return env.Depends(
        env.GenerateScriptBuilder(target),
        SomeUtils.getPyFilename(__file__))


def generate(env):
    GenerateScriptAction = SCons.Action.Action(
        generatePosixScript,
        "Creating wrapper script '$TARGET' for '$SOURCE'")
    GenerateScriptBuilder = SCons.Builder.Builder(
        action=[
            GenerateScriptAction,
            SCons.Defaults.Chmod(
                '$TARGET',
                0o755)],
        emitter=generateScriptEmitter)

    env.Append(BUILDERS={'GenerateScriptBuilder': GenerateScriptBuilder})
    env.AddMethod(generateWrapperScript, "GenerateWrapperScript")
    env.Append(CONFIGDIR='config')


def exists(env):
    return 1
