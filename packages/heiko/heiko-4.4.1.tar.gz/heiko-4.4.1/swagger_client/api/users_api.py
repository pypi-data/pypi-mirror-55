# coding: utf-8

"""
    MaaS

    MaaS (Matomat as a Service) API definition  # noqa: E501

    OpenAPI spec version: 0.5.2

    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class UsersApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def users_get(self, **kwargs):  # noqa: E501
        """List all users  # noqa: E501

        List all users  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_get(async=True)
        >>> result = thread.get()

        :param async bool
        :return: list[User]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.users_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.users_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def users_get_with_http_info(self, **kwargs):  # noqa: E501
        """List all users  # noqa: E501

        List all users  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_get_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: list[User]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['jwtTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[User]',  # noqa: E501
            auth_settings=auth_settings,
            is_async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_post(self, name, password, passwordrepeat, admin, **kwargs):  # noqa: E501
        """Add a new user  # noqa: E501

        Add a new user. Only admin users are allowed to do this. If \"admin\" is greater than 0, the new user will be created as admin user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_post(name, password, passwordrepeat, admin, async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: (required)
        :param str password: (required)
        :param str passwordrepeat: (required)
        :param int admin: (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.users_post_with_http_info(name, password, passwordrepeat, admin, **kwargs)  # noqa: E501
        else:
            (data) = self.users_post_with_http_info(name, password, passwordrepeat, admin, **kwargs)  # noqa: E501
            return data

    def users_post_with_http_info(self, name, password, passwordrepeat, admin, **kwargs):  # noqa: E501
        """Add a new user  # noqa: E501

        Add a new user. Only admin users are allowed to do this. If \"admin\" is greater than 0, the new user will be created as admin user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_post_with_http_info(name, password, passwordrepeat, admin, async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: (required)
        :param str password: (required)
        :param str passwordrepeat: (required)
        :param int admin: (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'password', 'passwordrepeat', 'admin']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `users_post`")  # noqa: E501
        # verify the required parameter 'password' is set
        if ('password' not in params or
                params['password'] is None):
            raise ValueError("Missing the required parameter `password` when calling `users_post`")  # noqa: E501
        # verify the required parameter 'passwordrepeat' is set
        if ('passwordrepeat' not in params or
                params['passwordrepeat'] is None):
            raise ValueError("Missing the required parameter `passwordrepeat` when calling `users_post`")  # noqa: E501
        # verify the required parameter 'admin' is set
        if ('admin' not in params or
                params['admin'] is None):
            raise ValueError("Missing the required parameter `admin` when calling `users_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'name' in params:
            form_params.append(('name', params['name']))  # noqa: E501
        if 'password' in params:
            form_params.append(('password', params['password']))  # noqa: E501
        if 'passwordrepeat' in params:
            form_params.append(('passwordrepeat', params['passwordrepeat']))  # noqa: E501
        if 'admin' in params:
            form_params.append(('admin', params['admin']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['jwtTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            is_async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_user_id_credits_add_patch(self, user_id, credits, **kwargs):  # noqa: E501
        """Add users credits  # noqa: E501

        Add users credits. This can only be done by the logged in user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_user_id_credits_add_patch(user_id, credits, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user for which the credits should be changed (required)
        :param int credits: (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.users_user_id_credits_add_patch_with_http_info(user_id, credits, **kwargs)  # noqa: E501
        else:
            (data) = self.users_user_id_credits_add_patch_with_http_info(user_id, credits, **kwargs)  # noqa: E501
            return data

    def users_user_id_credits_add_patch_with_http_info(self, user_id, credits, **kwargs):  # noqa: E501
        """Add users credits  # noqa: E501

        Add users credits. This can only be done by the logged in user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_user_id_credits_add_patch_with_http_info(user_id, credits, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user for which the credits should be changed (required)
        :param int credits: (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'credits']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_user_id_credits_add_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `users_user_id_credits_add_patch`")  # noqa: E501
        # verify the required parameter 'credits' is set
        if ('credits' not in params or
                params['credits'] is None):
            raise ValueError("Missing the required parameter `credits` when calling `users_user_id_credits_add_patch`")  # noqa: E501

        if 'credits' in params and params['credits'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `credits` when calling `users_user_id_credits_add_patch`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'credits' in params:
            form_params.append(('credits', params['credits']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['jwtTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{userId}/credits/add', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            is_async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_user_id_credits_transfer_patch(self, user_id, credits, **kwargs):  # noqa: E501
        """Transfer credits  # noqa: E501

        Transfers credits from logged in user to given user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_user_id_credits_transfer_patch(user_id, credits, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user to transfer credits to (required)
        :param int credits: (required)
        :return: TransferredCredits
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.users_user_id_credits_transfer_patch_with_http_info(user_id, credits, **kwargs)  # noqa: E501
        else:
            (data) = self.users_user_id_credits_transfer_patch_with_http_info(user_id, credits, **kwargs)  # noqa: E501
            return data

    def users_user_id_credits_transfer_patch_with_http_info(self, user_id, credits, **kwargs):  # noqa: E501
        """Transfer credits  # noqa: E501

        Transfers credits from logged in user to given user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_user_id_credits_transfer_patch_with_http_info(user_id, credits, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user to transfer credits to (required)
        :param int credits: (required)
        :return: TransferredCredits
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'credits']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_user_id_credits_transfer_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `users_user_id_credits_transfer_patch`")  # noqa: E501
        # verify the required parameter 'credits' is set
        if ('credits' not in params or
                params['credits'] is None):
            raise ValueError("Missing the required parameter `credits` when calling `users_user_id_credits_transfer_patch`")  # noqa: E501

        if 'credits' in params and params['credits'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `credits` when calling `users_user_id_credits_transfer_patch`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'credits' in params:
            form_params.append(('credits', params['credits']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['jwtTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{userId}/credits/transfer', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TransferredCredits',  # noqa: E501
            auth_settings=auth_settings,
            is_async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_user_id_credits_withdraw_patch(self, user_id, credits, **kwargs):  # noqa: E501
        """Widthdraw users credits  # noqa: E501

        Widthdraw users credits. A user can only withdraw as many credits as she currently has, if more than available are attempted to withdraw, an error is returned and no withdrawl performed. This can only be done by the logged in user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_user_id_credits_withdraw_patch(user_id, credits, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user for which the credits should be changed (required)
        :param int credits: (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.users_user_id_credits_withdraw_patch_with_http_info(user_id, credits, **kwargs)  # noqa: E501
        else:
            (data) = self.users_user_id_credits_withdraw_patch_with_http_info(user_id, credits, **kwargs)  # noqa: E501
            return data

    def users_user_id_credits_withdraw_patch_with_http_info(self, user_id, credits, **kwargs):  # noqa: E501
        """Widthdraw users credits  # noqa: E501

        Widthdraw users credits. A user can only withdraw as many credits as she currently has, if more than available are attempted to withdraw, an error is returned and no withdrawl performed. This can only be done by the logged in user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_user_id_credits_withdraw_patch_with_http_info(user_id, credits, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user for which the credits should be changed (required)
        :param int credits: (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'credits']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_user_id_credits_withdraw_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `users_user_id_credits_withdraw_patch`")  # noqa: E501
        # verify the required parameter 'credits' is set
        if ('credits' not in params or
                params['credits'] is None):
            raise ValueError("Missing the required parameter `credits` when calling `users_user_id_credits_withdraw_patch`")  # noqa: E501

        if 'credits' in params and params['credits'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `credits` when calling `users_user_id_credits_withdraw_patch`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'credits' in params:
            form_params.append(('credits', params['credits']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['jwtTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{userId}/credits/withdraw', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            is_async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_user_id_delete(self, user_id, **kwargs):  # noqa: E501
        """Delete user  # noqa: E501

        Delete user. This can only be done by the logged in user (for self) or an admin  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_user_id_delete(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The user ID that to perform the operation on (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.users_user_id_delete_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.users_user_id_delete_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def users_user_id_delete_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Delete user  # noqa: E501

        Delete user. This can only be done by the logged in user (for self) or an admin  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_user_id_delete_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The user ID that to perform the operation on (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_user_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `users_user_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['jwtTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{userId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            is_async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_user_id_get(self, user_id, **kwargs):  # noqa: E501
        """Get user by user ID  # noqa: E501

        Get user by user ID. Returns a user object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_user_id_get(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The user ID that to perform the operation on (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.users_user_id_get_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.users_user_id_get_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def users_user_id_get_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get user by user ID  # noqa: E501

        Get user by user ID. Returns a user object  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_user_id_get_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The user ID that to perform the operation on (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_user_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `users_user_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['jwtTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{userId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            is_async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_user_id_password_patch(self, user_id, password, passwordnew, passwordrepeat, **kwargs):  # noqa: E501
        """Change password for currently logged in user.  # noqa: E501

        Change password for currently logged in user. Must provide old and new passwords (twice) in order to be allowed to change it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_user_id_password_patch(user_id, password, passwordnew, passwordrepeat, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user for which the password should be changed (required)
        :param str password: (required)
        :param str passwordnew: (required)
        :param str passwordrepeat: (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.users_user_id_password_patch_with_http_info(user_id, password, passwordnew, passwordrepeat, **kwargs)  # noqa: E501
        else:
            (data) = self.users_user_id_password_patch_with_http_info(user_id, password, passwordnew, passwordrepeat, **kwargs)  # noqa: E501
            return data

    def users_user_id_password_patch_with_http_info(self, user_id, password, passwordnew, passwordrepeat, **kwargs):  # noqa: E501
        """Change password for currently logged in user.  # noqa: E501

        Change password for currently logged in user. Must provide old and new passwords (twice) in order to be allowed to change it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_user_id_password_patch_with_http_info(user_id, password, passwordnew, passwordrepeat, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user for which the password should be changed (required)
        :param str password: (required)
        :param str passwordnew: (required)
        :param str passwordrepeat: (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'password', 'passwordnew', 'passwordrepeat']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_user_id_password_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `users_user_id_password_patch`")  # noqa: E501
        # verify the required parameter 'password' is set
        if ('password' not in params or
                params['password'] is None):
            raise ValueError("Missing the required parameter `password` when calling `users_user_id_password_patch`")  # noqa: E501
        # verify the required parameter 'passwordnew' is set
        if ('passwordnew' not in params or
                params['passwordnew'] is None):
            raise ValueError("Missing the required parameter `passwordnew` when calling `users_user_id_password_patch`")  # noqa: E501
        # verify the required parameter 'passwordrepeat' is set
        if ('passwordrepeat' not in params or
                params['passwordrepeat'] is None):
            raise ValueError("Missing the required parameter `passwordrepeat` when calling `users_user_id_password_patch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'password' in params:
            form_params.append(('password', params['password']))  # noqa: E501
        if 'passwordnew' in params:
            form_params.append(('passwordnew', params['passwordnew']))  # noqa: E501
        if 'passwordrepeat' in params:
            form_params.append(('passwordrepeat', params['passwordrepeat']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['jwtTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{userId}/password', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            is_async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_user_id_resetpassword_patch(self, user_id, passwordnew, passwordrepeat, **kwargs):  # noqa: E501
        """Set password for user ID  # noqa: E501

        Set password for user ID. This can only be done by a logged in admin for a different user than self.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_user_id_resetpassword_patch(user_id, passwordnew, passwordrepeat, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user for which the password should be changed (required)
        :param str passwordnew: (required)
        :param str passwordrepeat: (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.users_user_id_resetpassword_patch_with_http_info(user_id, passwordnew, passwordrepeat, **kwargs)  # noqa: E501
        else:
            (data) = self.users_user_id_resetpassword_patch_with_http_info(user_id, passwordnew, passwordrepeat, **kwargs)  # noqa: E501
            return data

    def users_user_id_resetpassword_patch_with_http_info(self, user_id, passwordnew, passwordrepeat, **kwargs):  # noqa: E501
        """Set password for user ID  # noqa: E501

        Set password for user ID. This can only be done by a logged in admin for a different user than self.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_user_id_resetpassword_patch_with_http_info(user_id, passwordnew, passwordrepeat, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user for which the password should be changed (required)
        :param str passwordnew: (required)
        :param str passwordrepeat: (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'passwordnew', 'passwordrepeat']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_user_id_resetpassword_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `users_user_id_resetpassword_patch`")  # noqa: E501
        # verify the required parameter 'passwordnew' is set
        if ('passwordnew' not in params or
                params['passwordnew'] is None):
            raise ValueError("Missing the required parameter `passwordnew` when calling `users_user_id_resetpassword_patch`")  # noqa: E501
        # verify the required parameter 'passwordrepeat' is set
        if ('passwordrepeat' not in params or
                params['passwordrepeat'] is None):
            raise ValueError("Missing the required parameter `passwordrepeat` when calling `users_user_id_resetpassword_patch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'passwordnew' in params:
            form_params.append(('passwordnew', params['passwordnew']))  # noqa: E501
        if 'passwordrepeat' in params:
            form_params.append(('passwordrepeat', params['passwordrepeat']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['jwtTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{userId}/resetpassword', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            is_async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_user_id_stats_get(self, user_id, **kwargs):  # noqa: E501
        """Get matomat stats for user  # noqa: E501

        Get the matomat stats for user. A user can only request the stats for herself  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_user_id_stats_get(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user for which to fetch the stats (required)
        :return: UserStats
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.users_user_id_stats_get_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.users_user_id_stats_get_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def users_user_id_stats_get_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get matomat stats for user  # noqa: E501

        Get the matomat stats for user. A user can only request the stats for herself  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.users_user_id_stats_get_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: The ID of the user for which to fetch the stats (required)
        :return: UserStats
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_user_id_stats_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `users_user_id_stats_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['jwtTokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{userId}/stats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserStats',  # noqa: E501
            auth_settings=auth_settings,
            is_async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
