import datetime
from pytz import timezone
import math
import numpy
import logging
import sys
import argparse
import pkg_resources
import yaml
import pylab as pl
import os
import hashlib

standard_name_file = pkg_resources.resource_filename('pysst', 'rules/standard_names.yaml')

# Get the version
version_file = pkg_resources.resource_filename('pysst','VERSION')

with open(version_file) as version_f:
   version = version_f.read().strip()

# Setup logging module
logging.basicConfig(stream=sys.stderr, level=logging.INFO)
logger = logging.getLogger('pymrd')


class pymrd():
    """A object to read and process Sea & Sun Technology MRD files
    generated by the Microstructure profiler MSS.

    """ 
    def __init__(self,filename, only_metadata = False,verbosity =
                 logging.INFO, naming_rules = standard_name_file, baltic=None, calc_sha1=True):
        logger.setLevel(verbosity)
        logger.info(' Opening file: ' + filename)
        self.filename = filename
        self.file_type = ''
        self.channels = []
        self.data = None
        self.date = None        
        self.lon = numpy.NaN
        self.lat = numpy.NaN

        # Plotting variables
        self.figures = []
        self.axes    = []        
        # Opening file for reading
        try:
            self.f = open(self.filename,'rb')
        except Exception as e:
            logger.critical('Could not open file:' + self.filename + '( ' + str(e) + ' )')
            self.valid_mrd = False
            return

        # Opening file for reading and calculating sha1
        try:
            # Calculate a md5 hash
            if(calc_sha1):
               BLOCKSIZE = 65536
               hasher = hashlib.sha1()
               with open(self.filename, 'rb') as afile:
                   buf = afile.read(BLOCKSIZE)
                   while len(buf) > 0:
                      hasher.update(buf)
                      buf = afile.read(BLOCKSIZE)

               self.sha1 = hasher.hexdigest()
               afile.close()               
            else:
               self.sha1 = None
        except:
            logger.critical('Could not open file:' + self.filename)
            self.valid_mrd = False
            return
        
        self.read_MRD(pos_time_only = only_metadata) # Reading the binary 
        self._parse_header()

    def _parse_header(self):
        """ Parsing the header of the MRD file
        """
        header = self.header

        ind_ship = header.find('Ship    :   ') + len('Ship    :   ')
        ship = header[ind_ship:ind_ship+8]
        ship = ship.rstrip('_')

        ind_cruise = header.find('Cruise:') + len('Cruise:')
        cruise = header[ind_cruise+1:ind_cruise+18]
        cruise = cruise.rstrip('_')
        hs = header.split('\\r')
        sensor_str = []
        mss = None
        for i in range(17,len(hs)-1):
            sensor_str.append(hs[i])
            #if(hs[i].find('107') >=0):
            if(hs[i].upper().find('COUNT') >=0):
                mss = hs[i].split(' ')[1]

        if mss is not None:
            self.cruise = cruise
            self.ship   = ship
            self.mss    = mss
        else:
            logger.warning('Could not find a MSS')

        
    def get_info_dict(self):
        """ Returns a dictionary with the essential information
        """
        info_dict = {}
        info_dict['lon'] = self.lon
        info_dict['lat'] = self.lat
        info_dict['date'] = self.date
        info_dict['file'] = self.filename
        info_dict['sha1'] = self.sha1
        info_dict['type'] = 'MRD'
        return info_dict
    

    def read_MRD(self,pos_time_only = False):
        """ Getting metadata from an SST MRD file
        Args:
           pos_time_only: Read as much information to get date and position
        """
        
        f = self.f

        n = 0
        np = 0 # Number of packets
        end_of_header = 0
        end_of_header_tmp = 0
        IN_HEADER = True
        header    = b''
        HAVE_TIME = False
        HAVE_POS  = False


        while True:
            if HAVE_TIME & HAVE_POS & pos_time_only:
                break

            if(IN_HEADER):    
                b = f.read(1)
                n += 1        
            else:
                b = f.read(17)
                n += 17
                np += 1 # Number of 17 bytes long data packets (packet type + 8 words (little endian)

            if b != b"":
                # We are in the data body        
                if(IN_HEADER == False):
                    bword = []
                    for i in range(1,16,2): # Reading 16 bytes and treat them as words
                        bword.append(int.from_bytes(b[i:i+2],byteorder='little'))
                    if(b[0] == 1): # Time packet
                        if(HAVE_TIME == False):
                            year = int(bword[0])
                            year = bword[0]
                            month = bword[1]
                            day = bword[2]
                            hour = bword[4]
                            minute = bword[5]
                            second = bword[6]
                            date = datetime.datetime(year,month,day,hour,minute,second,tzinfo=timezone('UTC'))
                            self.date = date
                            HAVE_TIME = True

                    if(b[0] == 3): # Position packet
                        if(HAVE_POS == False):
                            # Latitude
                            latint    = int.from_bytes(b[1:3],byteorder='little')
                            latsign   = (latint & 0x8000) >> 15
                            if(latsign == 0):
                                latsign = -1
                            lat       = latint & 0x1FFF
                            latdeg    = (lat - lat%100)/100
                            latmindec = int.from_bytes(b[3:5],byteorder='little')
                            if(abs(latmindec) > 0):                            
                                digits    = int(math.log10(latmindec)) + 1
                            else:
                                digits    = 0
                                
                            latmin    = lat%100 + latmindec / 10**digits
                            latdec    = latsign * (latdeg + latmin/60)
                            # Longitude
                            lonint    = int.from_bytes(b[5:7],byteorder='little')
                            lonsign   = (lonint & 0x8000) >> 15
                            if(lonsign == 0):
                                lonsign = -1                
                            lon       = lonint & 0x1FFF
                            londeg    = (lon - lon%100)/100
                            lonmindec = int.from_bytes(b[7:9],byteorder='little')
                            if(abs(lonmindec) > 0):
                                digits    = int(math.log10(lonmindec)) + 1
                            else:
                                digits    = 0
                                
                            lonmin    = lon%100 + lonmindec / 10**digits
                            londec    = lonsign * (londeg + lonmin/60 )
                            # Daytime
                            tmp = (bword[6]) + (bword[4]&0x000F) * 100000
                            hour = int((tmp - tmp%10000)/10000)
                            tmp2 = tmp%10000
                            minute = int((tmp2 - tmp2%100)/100)
                            second = tmp2%100
                            self.lon = londec
                            self.lat = latdec                            
                            HAVE_POS = True

                    #if(b[0] == 7):
                    #    print('Sensors',b)
                    #    input('RE')

                else:
                    header += b
                    if(b == b'\x1A'): # Header is filled up with 0x1A until it is dividable by 17
                        end_of_header = n
                        # Check if dividable by 17
                        if((end_of_header)%17 == 0): # Dividable by 17
                            self.valid_mrd = True                            
                            #print('Found a valid header (dividable by 17)')
                            self.header = str(header)
                            IN_HEADER = False

            else:
                break


    def __str__(self):
        """
        String format
        """
        rstr = ""
        rstr += "pymrd of " + self.filename
        rstr += " at Lat: " + str(self.lat)
        rstr += ", Lon: " + str(self.lon)
        rstr += ", Date: " + datetime.datetime.strftime(self.date,'%Y-%m-%d %H:%M:%S')
        return rstr                    



# Main function
def main():
    sum_help         = 'Gives a csv compatible summary'
    plot_help        = 'Plots the MRD file, list the parameters in a comma separated list, e.g. --plot CT00,pt00,oxy use the arguments "show" to immidiately show the figure (will halt the code until the figure is closed) and/or "save" to save the figure'
    plot_prefix_help = 'The prefix before the filename, standars is "./", this is usefule to define a path and/or a fie prefix, e.g. --plot_prefix figures/ctd_casts_of_important_cruise__'
    var_help         = 'Lists all the available variables within the file, separated between the orignal data within the file (data) and the computed data (cdata)'        
    sumhead_help     = 'Gives the header to the csv compatible summary'
    parser = argparse.ArgumentParser()
    parser.add_argument('--variables', '-va', action='store_true', help=var_help)    
    parser.add_argument('--summary', '-s', action='store_true', help=sum_help)
    parser.add_argument('--summary_header', '-sh', action='store_true', help=sumhead_help)
    #https://stackoverflow.com/questions/13346540/argparse-optional-argument-before-positional-argument    
    parser.add_argument('--plot', '-p', nargs='?', help=plot_help)
    parser.add_argument('--plot_prefix', '-pre', nargs='?', help=plot_prefix_help)    
    parser.add_argument('--verbose', '-v', action='count')
    #parser.add_argument('--version', action='store_true')
    parser.add_argument('--version', action='version', version='%(prog)s ' + version)
    parser.add_argument('filename')    
    args = parser.parse_args()
    
    if(args.verbose == None):
        loglevel = logging.WARNING        
    elif(args.verbose == 1):
        loglevel = logging.INFO        
    elif(args.verbose == 2):
        loglevel = logging.DEBUG        
    else:
        loglevel = logging.INFO


    logger.setLevel(loglevel)


    filename = args.filename

    print_summary = args.summary
    print_summary_header = args.summary_header
    
    if(filename != None):
        mrd = pymrd(filename,verbosity=loglevel)
    else:
        #logger.critical('Need a filename')
        print(parser.print_help())


    if(args.variables):
        summary = mrd.get_variables()
        print(summary)

    if(print_summary_header):
        summary = mrd.get_summary(header=True)
        print(summary)
    if(print_summary):
        summary = mrd.get_summary()
        print(summary)

    #
    # Plot the file
    #
    if(args.plot != None):
        FLAG_SHOW = False
        FLAG_SAVE = False
        variables_plot = []
        for var in args.plot.split(','):
            if(var.upper() == 'SHOW'):
                FLAG_SHOW = True
            elif( var.upper() == 'SAVE'):
                FLAG_SAVE = True
            else:
                variables_plot.append(var)

        if(args.plot_prefix == None):
            plot_prefix = "./"
        else:
            plot_prefix = args.plot_prefix

        mrd.plot(xaxis=variables_plot,show=FLAG_SHOW,save=FLAG_SAVE,fig_prefix=plot_prefix)

            
if __name__ == '__main__':
   main()        
        
